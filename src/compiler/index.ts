import { chalk, fs, path, path as pathMod } from "../deps.ts";
import { toResponseFnDecl } from "../utils.ts";
import { HttpRouteFile } from "./http/HttpRouteFile.ts";
import { HttpRoutesTree } from "./http/HttpRoutesTree.ts";
import { graphToTerminal } from "./grapher/terminal.ts";
import {
  log_error,
  log_success,
  log_warn,
  makeLog_info,
  makeLog_success_v,
  MakeLogFn,
} from "./logger.ts";
import { CompileOptions } from "./types.ts";
import { httpDiscover } from "./http/discover.ts";

let log_info: MakeLogFn;
let log_success_v: MakeLogFn;

export async function compile(options: CompileOptions) {
  const opts = normalize_options(options);

  if (!(await request_permisions(opts))) return;

  const httpRoutesTree = await httpDiscover(opts);

  if (!httpRoutesTree) return;

  // Show route graph

  console.log("Route structure:");
  graphToTerminal(httpRoutesTree);
  console.log("");

  // Legend
  console.log(chalk.gray`★ Root Endpoint (Leaf)`);
  console.log(chalk.gray`☆ Root Invisible (Branch)`);
  console.log(chalk.gray`▲ Endpoint (Leaf)`);
  console.log(chalk.gray`△ Invisible (Branch)`);
  console.log(chalk.gray`■ Convention`);

  log_info("Writing files");

  // Remove old build
  // We use try-catch for handle 'No such file or directory' error
  try {
    await Deno.remove(opts.outDir, { recursive: true });
  } catch (_) {
    void 0;
  }
  await httpRoutesTree.writeFileIncremental();

  {
    // dusky.main.ts
    const mainPath = pathMod.join(opts.outDir, "http.main.ts");
    await fs.ensureFile(mainPath);
    await Deno.writeTextFile(
      mainPath,
      `// THIS FILE WAS GENERATED BY DUSKY-BACKEND (By Apika Luca)
import * as $Dusky$ from "dusky";
import { StatusCode } from "dusky/common.ts";
import mainHandler from "./http/index.ts";

${toResponseFnDecl()}

export default async function requestHandler(req: Deno.RequestEvent, conn: Deno.Conn): Promise<Response> {
  return toResponse(await mainHandler(new $Dusky$.HTTPRequest(req)) ?? new $Dusky$.HTTPError(StatusCode.NOT_FOUND));
}`,
    );
  }

  log_success("Done");
}

function normalize_options(options: CompileOptions): Required<CompileOptions> {
  const opts: Required<CompileOptions> = Object.assign(
    {
      routesPath: "",
      wsPath: false,
      outDir: ".dusky",
      verbose: false,
    },
    options,
  );

  opts.routesPath = path.resolve(Deno.cwd(), opts.routesPath);
  opts.outDir = path.resolve(Deno.cwd(), opts.outDir);
  if (opts.wsPath) opts.wsPath = path.resolve(Deno.cwd(), opts.wsPath);

  log_info = makeLog_info(opts.verbose);
  log_success_v = makeLog_success_v(opts.verbose);

  log_info(chalk`Options: 
  RoutesPath: {green "${opts.routesPath}"}
  OutDir: {green "${opts.outDir}"}
  Verbose: {yellow ${opts.verbose}}`);

  return opts;
}

async function request_permisions(
  opts: Required<CompileOptions>,
): Promise<boolean> {
  log_info("Prompting permissions");

  const request = async (desc: Deno.PermissionDescriptor, txt: string) => {
    switch ((await Deno.permissions.request(desc)).state) {
      case "granted":
        log_success_v(txt);
        return true;

      case "denied":
        log_error(txt);
        return false;

      default:
        return false;
    }
  };

  const read = (path: string) =>
    request(
      {
        name: "read",
        path: path,
      },
      chalk`Read permission {dim (${path})}`,
    );

  const write = (path: string) =>
    request(
      {
        name: "write",
        path: path,
      },
      chalk`Write permission {dim (${path})}`,
    );

  if (!(await read(opts.routesPath))) return false;
  if (!(await read(opts.outDir))) return false;
  if (!(await write(opts.outDir))) return false;

  log_success("Granted permissions");

  return true;
}
