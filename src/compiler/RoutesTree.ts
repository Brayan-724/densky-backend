import { createStreaming } from "https://deno.land/x/dprint@0.2.0/mod.ts";
import { fs, path, pathPosix } from "../deps.ts";
import { RouteFile } from "./RouteFile.ts";
import { RouteImport } from "./RouteImport.ts";
const pathMod = path;

// Setup Formatter
const tsFormatter = await createStreaming(
  fetch("https://plugins.dprint.dev/typescript-0.74.0.wasm")
);
tsFormatter.setConfig(
  { indentWidth: 2, lineWidth: 80 },
  { semiColons: "always", quoteStyle: "preferDouble", quoteProps: "asNeeded" }
);

export class RoutesTree {
  children = new Set<RoutesTree>();
  readonly dirname: string;
  readonly relativePath: string;

  readonly exactMatcher: string;
  readonly startsMatcher: string;

  constructor(
    readonly path: string,
    readonly filePath: string,
    public routeFile: RouteFile | null,
    readonly isRoot: boolean = false
  ) {
    this.dirname = pathMod.dirname(filePath);
    this.relativePath = pathMod.relative(Deno.cwd(), filePath);

    path = path.trim();

    // Normalize to have slash at the beginning
    if (!pathPosix.isAbsolute(path)) {
      path = "/" + path;
    }

    this.path = path;
    this.exactMatcher = `req.pathname === "${this.path}"`;
    this.startsMatcher = `req.pathname.startsWith("${this.path}")`;
  }

  addChild(route: RoutesTree) {
    this.children.add(route);

    return this;
  }

  generateImports(): string {
    if (this.routeFile) this.routeFile.outPath = this.filePath;

    const childrenImports = Array.from(this.children)
      .map((child, i) => {
        return `import $child$${i} from "./${path.relative(
          this.dirname,
          child.filePath
        )}"`;
      })
      .join(";\n");

    return `import * as $Dusky$ from "dusky";
${childrenImports}`;
  }

  getRouteIdentImports(): Map<string, RouteImport> {
    if (!this.routeFile) return new Map();

    const map = new Map<string, RouteImport>();

    this.routeFile.imports.forEach(([im, path]) => {
      const def = RouteImport.getDefOf(im);

      const routeImport = map.get(path) ?? new RouteImport(path);

      // Add if has
      def.multiImports && routeImport.addMultiImports(def.multiImports);
      def.defaultImport && routeImport.addDefaultImport(def.defaultImport);
      def.starImport && routeImport.addStarImport(def.starImport);

      map.set(path, routeImport);
    });

    return map;
  }

  generateHandler() {
    const childCalls = Array.from(this.children)
      .map(
        (_, i) =>
          `const out$${i} = await $child$${i}(req); if (out$${i}) return out$${i}`
      )
      .join(";\n");

    const hasAny = this.routeFile?.handlers?.has("ANY") ?? false;

    const bodyContent = this.routeFile
      ? Array.from(this.routeFile.handlers.entries())
          .map(([method, handl]) => {
            return method !== "ANY"
              ? `if (req.method === "${method}") {
        ${handl.body}
      }`
              : handl.body;
          })
          .join("\n") +
        (!hasAny
          ? "\n\nreturn new $Dusky$.HTTPError($Dusky$.StatusCode.NOT_METHOD).toResponse()"
          : "")
      : "";

    const body = this.routeFile
      ? `if (${this.exactMatcher}) { ${bodyContent} }`
      : "";

    return childCalls + ";\n\n" + body;
  }

  buildFile(): string {
    const imports = this.generateImports();
    const routeImports = this.getRouteIdentImports();
    const body = this.generateHandler();

    const routeImportsStr: string[] = [];

    routeImports.forEach((routeImport) => {
      const out = new RouteImport(routeImport.path);

      // For every ident, if can find it inside of body, then put it
      // else, just ignore it
      routeImport.getAllIdents().forEach((ty, ident) => {
        if (body.match(RouteImport.getMatcherOf(ident)) !== null) {
          out.addImport(ident, ty);
        }
      });

      const str = out.toImportString();
      if (str.length > 0) routeImportsStr.push(str);
    });

    const handler =
      this.isRoot || this.children.size === 0
        ? body
        : `if (${this.startsMatcher}) {${body}}`;

    const content = `
// ${this.relativePath}
// THIS FILE WAS GENERATED BY DUSKY-BACKEND (by Apika Luca)
${imports}
${routeImportsStr.join(";\n")}

async function handler(req: $Dusky$.HTTPRequest): Promise<Response | $Dusky$.HTTPResponse | $Dusky$.HTTPError | void> {
  ${handler}
}

export default handler;
`;

    return tsFormatter.formatText(this.filePath, content);
  }

  async writeFile() {
    await fs.ensureDir(pathMod.dirname(this.filePath));
    await Deno.writeTextFile(this.filePath, this.buildFile());
  }

  async writeFileIncremental() {
    await this.writeFile();
    await Promise.all(
      Array.from(this.children).map((ch) => ch.writeFileIncremental())
    );
  }
}
