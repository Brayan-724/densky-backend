import { createStreaming } from "https://deno.land/x/dprint@0.2.0/mod.ts";
import { fs, path, pathPosix } from "../deps.ts";
import { UrlMatcher, urlToMatcher } from "../utils.ts";
import { RouteFile } from "./RouteFile.ts";
import { RouteImport } from "./RouteImport.ts";
const pathMod = path;

// Setup Formatter
const tsFormatter = await createStreaming(
  fetch("https://plugins.dprint.dev/typescript-0.74.0.wasm")
);
tsFormatter.setConfig(
  { indentWidth: 2, lineWidth: 80 },
  { semiColons: "always", quoteStyle: "preferDouble", quoteProps: "asNeeded" }
);

export class RoutesTree {
  parent: RoutesTree | null = null;
  children = new Set<RoutesTree>();
  fallback: RoutesTree | null = null;
  readonly dirname: string;
  readonly relativePath: string;

  readonly matcher: UrlMatcher;

  constructor(
    readonly path: string,
    readonly filePath: string,
    public routeFile: RouteFile | null,
    readonly isRoot: boolean = false
  ) {
    this.dirname = pathMod.dirname(filePath);
    this.relativePath = pathMod.relative(Deno.cwd(), filePath);

    path = path.trim();

    // Normalize to have slash at the beginning
    if (!pathPosix.isAbsolute(path)) {
      path = "/" + path;
    }

    this.path = path;
    this.matcher = urlToMatcher(this.path);
  }

  addChild(route: RoutesTree) {
    route.parent = this;
    if (route.path.endsWith("_fallback")) {
      this.fallback = route;
    } else {
      this.children.add(route);
    }

    return this;
  }

  generateImports(): string {
    if (this.routeFile) this.routeFile.outPath = this.filePath;

    const childrenImports = Array.from(this.children)
      .map((child, i) => {
        return `import $child$${i} from "./${path.relative(
          this.dirname,
          child.filePath
        )}"`;
      })
      .join(";\n");

    return `import * as $Dusky$ from "dusky";
${childrenImports}`;
  }

  getRouteIdentImports(): Map<string, RouteImport> {
    if (!this.routeFile) return new Map();

    const map = new Map<string, RouteImport>();

    this.routeFile.imports.forEach(([im, path]) => {
      const def = RouteImport.getDefOf(im);

      const routeImport = map.get(path) ?? new RouteImport(path);

      // Add if has
      def.multiImports && routeImport.addMultiImports(def.multiImports);
      def.defaultImport && routeImport.addDefaultImport(def.defaultImport);
      def.starImport && routeImport.addStarImport(def.starImport);

      map.set(path, routeImport);
    });

    return map;
  }

  generateBodyContent() {
    const hasAny = this.routeFile?.handlers?.has("ANY") ?? false;

    return this.routeFile
      ? Array.from(this.routeFile.handlers.entries())
          .map(([method, handl]) => {
            return method !== "ANY"
              ? `if (req.method === "${method}") {
        ${handl.body}
      }`
              : handl.body;
          })
          .join("\n") +
          (!hasAny
            ? "\n\nreturn new $Dusky$.HTTPError($Dusky$.StatusCode.NOT_METHOD).toResponse()"
            : "")
      : "";
  }

  generateHandler() {
    const childCalls = Array.from(this.children)
      .map(
        (_, i) =>
          `const out$${i} = await $child$${i}(req); if (out$${i}) return out$${i}`
      )
      .join(";\n");

    const bodyContent = this.generateBodyContent();

    const body = this.routeFile
      ? `if (${this.matcher.exactDecl("pathname")}) { ${bodyContent} }`
      : "";

    return childCalls + ";\n\n" + body;
  }

  buildFile(): string {
    const imports = this.generateImports();
    const routeImports = this.getRouteIdentImports();
    let body = this.generateHandler();

    const routeImportsStr: string[] = [];

    routeImports.forEach((routeImport) => {
      routeImport.filterUnused(body);

      const str = routeImport.toImportString();
      if (str.length > 0) routeImportsStr.push(str);
    });

    if (this.fallback) {
      body += this.fallback.generateBodyContent();

      this.fallback.getRouteIdentImports().forEach((routeImport) => {
        routeImport.filterUnused(body);

        const str = routeImport.toImportString();
        if (str.length > 0) routeImportsStr.push(str);
      });
    }

    const handler =
      this.isRoot || (this.children.size === 0 && this.fallback === null)
        ? body
        : `if (${this.matcher.startDecl("pathname")}) {${body}}`;

    const content = `// deno-lint-ignore-file
// ${this.relativePath}
// THIS FILE WAS GENERATED BY DUSKY-BACKEND (by Apika Luca)
${imports}
${routeImportsStr.join(";\n")}

async function handler(req: $Dusky$.HTTPRequest): Promise<Response | $Dusky$.HTTPResponse | $Dusky$.HTTPError | void> {
  ${this.matcher.prepareDecl("pathname", "req.pathname")}
  ${handler}
}

export default handler;
`;

    return tsFormatter.formatText(this.filePath, content);
  }

  async writeFile() {
    await fs.ensureDir(pathMod.dirname(this.filePath));
    await Deno.writeTextFile(this.filePath, this.buildFile());
  }

  async writeFileIncremental() {
    await this.writeFile();
    await Promise.all(
      Array.from(this.children).map((ch) => ch.writeFileIncremental())
    );
  }
}
